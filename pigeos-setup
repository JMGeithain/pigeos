#!/bin/bash
# (c) 2020-21 T.Hass
#
# USAGE pigeos-setup [<command>] [<parameters>]
#
# COMMANDS:
# 	setup		downloads files from GitHub and installs into the current system
# 	configure 	(re)configure all services using the current user config
#	update		update the Pi/GEOS by downloading lastest file from GitHub
# 	help  	  	show advanced help (manual)
#
# 	install_<service> expert options to install/configure a specific service
# 	config_<service>  
#
###
#
# NAME: Pi/GEOS SETUP v0.9
#
# PURPOSE: Pi/GEOS installation und setup utillity
#
# DESCRIPTION: This utility is used to install the Pi/GEOS specific extensions
# into a vanilla Raspberry Pi OS (Raspbian) lite image. It is also called by
# pigeos-config after the user has modified the local configuration file
# ($HOME/.pigeos) to apply configuration changes to the system.
#
# setup
# 	is the recommended method to deploy and update for regular users. A working
# 	internet connection is required to work properly. Please refer to the
# 	official documentation how to setup this. Raspberry Pi imaging utility
# 	advanced options (Shift+Ctrl+X) are the recommended way to preconfigure
# 	Wifi and locale settings when preparing a boot device (SD card).
# 	The 1st stage installation can also run in an chroot environment on
# 	a development system.
# install_stage2
# 	is called by pigeos-loader to finish a fresh a fresh installation.
# 	No internet connection is required for this stage but it must only
# 	be executed from within a running Pi/GEOS installation (after image
# 	image resize has successfully finished).
# configure
# 	is called by pigeos-config the the interactive configuration utility. 
# 	Is is usualy not intended to be used by the enduser direcly.
# 	
# SEE ALSO: pigeos-config, pigeos-loader
#
#####

# setup for usage and manual
PROGNAME=$(type $0 | cut -d ' ' -f 3)
PROGDIR=$(dirname $PROGNAME)
PROGNAME=$(basename $PROGNAME)
# essential raspi configuration files
BOOT_CONFIG=/boot/config.txt
BOOT_CMDLINE=/boot/cmdline.txt
# a per device unique string to edentify this in a network
PIGEOS_SN=$(cat /sys/firmware/devicetree/base/serial-number | sed 's/\x0//')
# base for Pi/GEOS system files and binaries
PIGEOS_PREFIX=/usr/local
# base for user configuration files
PIGEOS_USER=$(who | grep tty1 | head -1 | cut -d\  -f 1)
PIGEOS_USER=${PIGEOS_USER:-pi} # default to pi when executed in a chroot env.
PIGEOS_HOME=$(grep "^$PIGEOS_USER:" /etc/passwd | cut -d: -f 6)
# which dosbox binary should be launched?
DOSBOX_BIN=$PIGEOS_PREFIX/bin/dosbox
# global depencies: gldriver-test libgl1-mesa-dri 
PKG_LIST="fbi jq pv mtools"
# list of external files need to be installed by this script in net_install mode
# TODO setup a APT repo for the customized version of DOSBox
URL_DOSBOX_PKG="https://dl.dropbox.com/s/8zg8q5o2mgwoqgf/dosbox-pigeos-0.74.2_armhf.deb"
URL_DOSBOX_LANG=(\
  "https://raw.githubusercontent.com/hastho/pigeos/master/defaults/mapper-0.74.map.de_DE.UTF-8" \
  "https://raw.githubusercontent.com/hastho/pigeos/master/defaults/mapper-0.74.map.en_GB.UTF-8" \
)
URL_DOSBOX_CONFIG="https://raw.githubusercontent.com/hastho/pigeos/master/defaults/dosbox-0.74.conf"
# a free for non-commercial use file sync tool
URL_RSLSYNC_PKG="https://download-cdn.resilio.com/stable/linux-armhf/resilio-sync_armhf.tar.gz"
# a classic modem style dialing sound
URL_DIALING_SOUND="https://upload.wikimedia.org/wikipedia/commons/3/33/Dial_up_modem_noises.ogg"
# a font to be used in the BIOS splash screen and splash screen template
URL_FONTS="https://int10h.org/oldschool-pc-fonts/download/oldschool_pc_font_pack_v1.01.zip"
URL_SPLASH="https://raw.githubusercontent.com/hastho/pigeos/master/gfx/splash_tpl.png"
# pigeos configuration and helper scripts
URL_SETUP_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-setup"
URL_IMAGE_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-image"
URL_PRINT_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-print"
URL_LOADER_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-loader"
URL_SPLASH_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-splash"
# Pi/GEOS configuration script, fixed values configuration file and language files
URL_CONFIG_SCRIPT="https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-config"
URL_CONFIG_SYSCFG="https://raw.githubusercontent.com/hastho/pigeos/master/defaults/pigeos.conf"
URL_CONFIG_LANG=(\
  "https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-config.de_DE.UTF-8" \
  "https://raw.githubusercontent.com/hastho/pigeos/master/pigeos-config.en_GB.UTF-8" \
)

LOG_FILE=/tmp/$(basename $0).log

# this array is to map pidos config to systemctl: 0->disable, 1->enable
declare -a disable_enable=("disable" "enable")
declare -a false_true=("false" "true")

usage() {
  echo "" >&2
  echo "$PROGNAME:" "$@" >&2
  sed -n '/^###/q; /^#/!q; s/^#//; s/^ //; 4,$p' "$PROGDIR/$PROGNAME" >&2
  exit 254
}

help() {
  echo "" >&2
  echo "$PROGNAME:" "$@" >&2
  sed -n '/^#####/q; /^#/!q; s/^#*//; s/^ //; 4,$p' "$PROGDIR/$PROGNAME" >&2
  exit 254
}

download_file() {
  wget -q "$1" -O "$2"  || return 1
  return 0
}

install_dep_pkg() {
	local retryc=3
    sudo apt update
    while [ $retryc -gt 0 ]; do
		sudo apt-get -y install $* && retryc=0
	done
	sudo apt clean
}

install_pigeos_scripts() {
  for file_url in "$URL_IMAGE_SCRIPT" "$URL_LOADER_SCRIPT"\
                  "$URL_SPLASH_SCRIPT" "$URL_CONFIG_SCRIPT"\
				  "$URL_PRINT_SCRIPT" "$URL_SETUP_SCRIPT"
  do
    download_file "$file_url" /tmp/$(basename "$file_url")
    sudo install -D /tmp/$(basename "$file_url") \
	  $PIGEOS_PREFIX/bin/$(basename "$file_url")
  done
}

install_pigeos_config() {
  # download the default config
  download_file "$URL_CONFIG_SYSCFG" /tmp/$(basename "$URL_CONFIG_SYSCFG")
  sudo install -D  /tmp/$(basename "$URL_CONFIG_SYSCFG")\
     $PIGEOS_PREFIX/etc/$(basename "$URL_CONFIG_SYSCFG")
  for lang in ${URL_CONFIG_LANG[@]}; do
    download_file "$lang" /tmp/$(basename "$lang")
	sudo install -D          /tmp/$(basename "$lang")\
	  $PIGEOS_PREFIX/share/pigeos/$(basename "$lang")
  done
  # create user config if not present
  test -f  ${PIGEOS_HOME}/.pigeos \
  	|| echo ". $PIGEOS_PREFIX/etc/$(basename $URL_CONFIG_SYSCFG)" \
	 > ${PIGEOS_HOME}/.pigeos
  # change owner to Pi/GEOS user in case this script was exec. as root
  chown -R ${PIGEOS_USER}.${PIGEOS_USER} \
           ${PIGEOS_HOME}/.pigeos

}

install_dosbox_pkg() {
  # dosbox-pigeos requires SDL-1.2 and libpacp for Ethernet emulation
  install_dep_pkg libsdl1.2debian libsdl-sound1.2 libsdl-net1.2 libpcap0.8
  # ToDo build a official repository
  download_file "$URL_DOSBOX_PKG" /tmp/dosbox.deb
  # remove package from blacklist
  echo "dosbox install" | sudo dpkg --set-selections
  sudo dpkg -i /tmp/dosbox.deb
  # blacklist dosbox package so it will not be replaced
  # with the system default dosbox during any upgrades
  echo "dosbox hold" | sudo dpkg --set-selections
  # install a custom DOSBox configuration
  download_file "$URL_DOSBOX_CONFIG" /tmp/$(basename "$URL_DOSBOX_CONFIG")
  install -D /tmp/$(basename "$URL_DOSBOX_CONFIG")\
    $PIGEOS_HOME/.dosbox/$(basename "$URL_DOSBOX_CONFIG") 
  # download locallized key maps
  for lang in ${URL_DOSBOX_LANG[@]}; do
    download_file "$lang"    /tmp/$(basename "$lang")
	sudo install -D          /tmp/$(basename "$lang")\
	  $PIGEOS_PREFIX/share/pigeos/$(basename "$lang")
  done
  # create folder to store the disk images
  test -d $PIGEOS_HOME/hdd_images || mkdir $PIGEOS_HOME/hdd_images
  test -d $PIGEOS_HOME/fdd_images || mkdir $PIGEOS_HOME/fdd_images
  # change owner to Pi/GEOS user in case this script was exec. as root
  chown -R ${PIGEOS_USER}.${PIGEOS_USER} \
           ${PIGEOS_HOME}/{.dosbox,fdd_images,hdd_images}
}

config_dosbox_pkg() {
  # link DOSBox mapper file for the given language
  ln -sf $PIGEOS_PREFIX/share/pigeos/mapper-0.74.map.$LANG \
         $PIGEOS_HOME/.dosbox/mapper-0.74.map
}

install_splash_screen() {
  # This custom splash screen simluates a PC BIOS
  # screen and provides some information about the
  # current Pi/GEOS configuration.
  echo "Creating splash screen service" 
  install_dep_pkg imagemagick 
  # template for the spash screen
  download_file $URL_SPLASH \
    /tmp/splash_tpl.png 2>&1
  sudo install -D /tmp/splash_tpl.png  \
    $PIGEOS_PREFIX/share/pigeos/splash_tpl.png 2>&1
  sudo mkdir -p $PIGEOS_PREFIX/lib/pigeos 2>&1
  # special font used by BIOS manufacturers
  download_file $URL_FONTS \
    /tmp/ultimate_oldschool_pc_font_pack.zip 2>&1
  unzip -jod /tmp /tmp/ultimate_oldschool_pc_font_pack.zip \
    '*/Px437_PhoenixEGA_8x16.ttf' 2>&1 
  sudo install -D /tmp/Px437_PhoenixEGA_8x16.ttf \
    /usr/share/fonts/truetype/oldschool_pc_font/Px437_PhoenixEGA_8x16.ttf 2>&1
  sudo fc-cache -f 2>&1
  # create image config params req. by pigeos-splash, if not present
  for param in FDA_IMAGE FDB_IMAGE HDC_IMAGE HDD_IMAGE; do
    grep -q   "${param}=.*"   	$PIGEOS_HOME/.pigeos \
	  || echo "${param}=NONE" >>$PIGEOS_HOME/.pigeos
  done
  sudo tee /etc/systemd/system/splash_screen.service >/dev/null <<SPLASH_SCR
[Unit]
Description=Pi/GEOS splash screen service
DefaultDependencies=no

[Service]
ExecStart=/usr/bin/fbi -noverbose  /usr/local/lib/pigeos/splash.png

StandardInput=tty
StandardOutput=tty


[Install]
WantedBy=multi-user.target
SPLASH_SCR
}

config_splash_screen() {
  pigeos-splash update 2>&1
  # enable service
  sudo systemctl daemon-reload 2>&1
  sudo systemctl --now enable splash_screen 2>&1
  return 0
}

install_dosbox_modem() {
  # DOSBox will foreward it's virtuel modem connection
  # to a local telnet port that will be redirects to
  # a virtuel TTy where a PPPD can bind to
  echo -n "Creating modem service "
  install_dep_pkg iptables ppp socat vorbis-tools 
  sudo tee /etc/systemd/system/modem@.service >/dev/null <<MODEM_SRV
[Unit]
Description=Start DOSBox virtual modem on given TTY
After=network.target
StartLimitIntervalSec=0
StartLimitBurst=3000

[Service]
Restart=always
RestartSec=3
Type=simple
PIDFile=/run/modem-%i.pid
ExecStart=/usr/bin/socat -L/run/modem-%i.pid -d -d -s -lf /var/log/modem-%i.log TCP4-LISTEN:23,bind=127.0.0.1 PTY,link=/dev/%i,raw,echo=0,b57600 

[Install]
WantedBy=multi-user.target
MODEM_SRV
  echo done.

  # as the virtual TTy is only created by socat when DOSBox
  # establishes a modem connection PPPD service can only
  # be started after the TTY has been created.
  sudo tee /etc/systemd/system/pppd@.path >/dev/null <<PPP_MON
[Unit]
Description=Start PPP, if the given (SoCAT) TTY is present

[Path]
PathExists=/dev/%i

[Install]
WantedBy=multi-user.target
PPP_MON

  # before PPPD will be started a nice modem dialing sound will
  # be played :) At this point NAT will be activated for all
  # interfaces and connection tracking roles to allow active
  # FTP (req. by the GEOS FTP client) are aplied.
  # 
  sudo tee /etc/systemd/system/pppd@.service >/dev/null <<PPP_SRV
[Unit]
Description=Start PPPD for the given TTY

[Service]
Type=simple
EnvironmentFile=/etc/default/pppd-%i.conf
PIDFile=/run/pppd%i.pid
ExecStartPre=-/usr/bin/ogg123 /usr/local/share/sound/dialing.ogg
ExecStartPre=/sbin/iptables -t nat -A POSTROUTING -s \$PPPD_NETWORK -j MASQUERADE
ExecStartPre=/sbin/iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
ExecStartPre=/sbin/iptables -A PREROUTING -t raw -p tcp --dport 21 -j CT --helper ftp
ExecStart=/usr/sbin/pppd /dev/%i \$PPPD_CONNECTION \$PPPD_DEFAULTS
PPP_SRV

  # PPPD configuration is different for any serial line and
  # the IP ranges need to be modified. 
  sudo tee /etc/default/pppd-ttyN0.conf >/dev/null <<PPP_CFG
PPPD_DEFAULTS=nodetach local noauth
PPPD_NETWORK=192.168.6.0/30
PPPD_CONNECTION=57600 192.168.6.1:192.168.6.2
PPP_CFG

  # load kernel modules to allow active FTP
  grep -e 'nf_conntrack_ftp|nf_nat_ftp' /etc/modules-load.d/modules.conf \
  || sudo tee -a /etc/modules-load.d/modules.conf >/dev/null <<FTP_MOD
nf_conntrack_ftp
nf_nat_ftp
FTP_MOD

  # enable routing
  sudo tee /etc/sysctl.d/98-ppd.conf >/dev/null <<PPP_SYSCTL
net.ipv4.ip_forward=1
PPP_SYSCTL
}

config_dosbox_modem() {
  # reload system configuration and enable/start services
  sudo sysctl -p /etc/sysctl.conf
  sudo modprobe nf_nat_ftp
  sudo systemctl daemon-reload
  sudo systemctl --now enable modem@ttyN0
  sudo systemctl --now enable pppd@ttyN0.path

  # Configure DOSBox with modem connected on COM1
  sed -i 's/serial1=.*/serial1=modem/' $($DOSBOX_BIN -printconf)
  return 0
}

install_dosbox_telnetd() {
  # install a simple telnet service on localhost that can be accessed from
  # GEOS via DOSBox COM2 nullmodem link
  install_dep_pkg socat
  sudo tee /etc/systemd/system/telnetd.service >/dev/null <<TELNET_SRV
[Unit]
Description=Start DOSBox null-modem host link
After=network.target
StartLimitIntervalSec=0
StartLimitBurst=3000

[Service]
Restart=always
RestartSec=3
Type=simple
PIDFile=/run/telnetd.pid
ExecStart=/usr/bin/socat -L /run/telnetd.pid -d -d -s -lf /var/log/telnetd.log  TCP4-LISTEN:2023,bind=127.0.0.1 exec:"/sbin/agetty --autologin pi --noclear - -- vt100",pty,raw,echo=0,b57600

[Install]
WantedBy=multi-user.target
TELNET_SRV
}

config_dosbox_telnetd() {
  sudo systemctl daemon-reload
  sudo systemctl --now enable telnetd

  # Configure DOSBox to have a nullmodem link on COM2
  sed -i 's/serial2=.*/serial2=nullmodem server:127.0.0.1 port:2023/' \
  	$($DOSBOX_BIN -printconf) 
}

install_pigeos_loader() {
  # raspi-config will switch to text console mode and 
  # enables auto-login  on TTY1 for the user who executes this script
  sudo /usr/bin/raspi-config nonint do_boot_behaviour B2
  # to make the login realy "silent" so that no output apears between the BIOS splash 
  # and theDOSBox splash the autologin.conf file needs to be modified
  sudo tee /etc/systemd/system/getty@tty1.service.d/autologin.conf >/dev/null <<LOGIN_AUTO
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --skip-login --login-program /bin/login --login-options '-f pi'  %I \$TERM
LOGIN_AUTO
  # also remove the "last login" message
  sudo sed -i 's/^LASTLOG_ENAB/#LASTLOG_ENAB/' /etc/login.defs
  # create a login profile setting to exec the Pi/GEOS loader after login
  sudo tee /etc/profile.d/10-pigeos.sh >/dev/null <<LOGIN_PROF
if [ "\$(tty)" = "/dev/tty1" ]; then
  $PIGEOS_PREFIX/bin/pigeos-loader
fi
LOGIN_PROF
  # disable license msg at login
  touch $PIGEOS_HOME/.hushlogin
}

install_cups() {
  install_dep_pkg cups cups-browsed cups-client cups-bsd
  # enable automatic print queue creation for AirPrint printer found
  sudo sed -i 's/^CreateIPPPrinterQueues.*/CreateIPPPrinterQueues Driverless/' \
    /etc/cups/cups-browsed.conf
  sudo usermod -aG lpadmin $PIGEOS_USER 
}

config_cups() {
  sudo systemctl --now ${disable_enable[$CUPS_SLOAD]} cups 2>$LOG_FILE 1>&2
  sudo systemctl --now ${disable_enable[$CUPS_SLOAD]} cups-browsed 2>$LOG_FILE 1>&2
  # enable remote administration of printers used by Pi/GEOS
  if [ $CUPS_ADMIN -eq 1 ]; then 
    cupsctl --remote-admin 2>$LOG_FILE 1>&2
  else
    cupsctl --no-remote-admin 2>$LOG_FILE 1>&2
  fi
  if [ $CUPS_ADMIN -eq 1 ]; then
    cupsctl --remote-any 2>$LOG_FILE 1>&2
  else
    cupsctl --no-remote-any 2>$LOG_FILE 1>&2
  fi
}

install_jed() {
  install_dep_pkg jed
  # make the jed editor look & feel like on DOS
  cat >$PIGEOS_HOME/.jedrc <<JEDRC
() = evalfile ("cua");
set_color_scheme ("blue3");
TAB_DEFAULT = 4;
JEDRC
}

install_usbmount() {
  install_dep_pkg usbmount
  # add the pi user to the disk group
  sudo usermod -aG disk $PIGEOS_USER  
  # usbmount failed without this setting
  sudo mkdir -p /etc/systemd/system/systemd-udevd.service.d
  sudo tee /etc/systemd/system/systemd-udevd.service.d/override.conf >/dev/null <<PRIV_MNT
[Service]
PrivateMounts=no
PRIV_MNT
}

config_usbmount() {
  # set mount option to automount VFAT USB devices and allow write acces for the pi user
  [[ $MOUNT_USB -eq 1 ]] \
  	&& sudo sed -i 's/^FS_MOUNTOPTIONS=.*/FS_MOUNTOPTIONS="-fstype=vfat,gid=disk,dmask=0007,fmask=0117"/' \
	   /etc/usbmount/usbmount.conf \
 	|| sudo sed -i 's/^FS_MOUNTOPTIONS=.*/FS_MOUNTOPTIONS=""/' \
	   /etc/usbmount/usbmount.conf
}

install_midi() {
  install_dep_pkg timidity-daemon 
}

config_midi() {
  sudo systemctl --now ${disable_enable[$MIDI_SLOAD]} timidity 2>$LOG_FILE 1>&2
  # route midi output to timidity
  [[ $MIDI_SLOAD -eq 1 ]] \
  	&& sed -i 's/midiconfig\s*=.*/midiconfig=128:0/'  $($DOSBOX_BIN -printconf) \
	|| sed -i 's/midiconfig\s*=.*/midiconfig=/'   	  $($DOSBOX_BIN -printconf)
}

install_rslsync() {
  download_file $URL_RSLSYNC_PKG /tmp/$(basename $URL_RSLSYNC_PKG)
  tar xzf $(basename $URL_RSLSYNC_PKG)
  sudo install rslsync 		$PIGEOS_PREFIX/bin
  sudo install LICENSE.TXT 	$PIGEOS_PREFIX/share/pigeos/resilio.lic
  # TODO create systemd service
    sudo tee /etc/systemd/system/rslsync@.service >/dev/null <<RSLSYNC_SRV
[Unit]
Description=Start Resilio Sync Service
After=network.target
StartLimitIntervalSec=0
StartLimitBurst=3000

[Service]
Restart=always
RestartSec=3
Type=simple
User=%i
Group=%i
PIDFile=/home/%i/.sync/resilio.pid
ExecStart=$PIGEOS_PREFIX/bin/rslsync --nodaemon --config /home/%i/.sync/config.json 

[Install]
WantedBy=multi-user.target
RSLSYNC_SRV
}

config_rslsync() {
  # stop service before updating its config
  sudo systemctl --now disable rslsync@${PIGEOS_USER} 2>$LOG_FILE 1>&2
  # generate sync key if service is enabled but no key given
  if [ "x$RSLSYNC_KEY" == "x" -a $RSLSYNC_SLOAD -eq 1 ]; then
    RSLSYNC_KEY=$(rslsync --generate-secret)
  fi
  test -d $PIGEOS_HOME/Shared 	|| mkdir $PIGEOS_HOME/Shared
  test -d $PIGEOS_HOME/.sync 	|| mkdir $PIGEOS_HOME/.sync
  tee $PIGEOS_HOME/.sync/config.json >/dev/null <<RSLCFG
{
  "device_name"         : "Pi/GEOS S/N: ${PIGEOS_SN}",
  "listening_port"      : 0,
  "storage_path"        : "$PIGEOS_HOME/.sync",
  "pid_file"            : "$PIGEOS_HOME/.sync/resilio.pid",
  "use_upnp"            : ${false_true[$RSLSYNC_WAN]},
  "download_limit"      : 0,
  "upload_limit"        : 0,
  "directory_root"      : "$PIGEOS_HOME/",
  "shared_folders"      :
  [
    {
      "secret"          : "$RSLSYNC_KEY",
      "dir"             : "$PIGEOS_HOME/Shared",
      "use_relay_server" : ${false_true[$RSLSYNC_WAN]},
      "use_tracker"     : ${false_true[$RSLSYNC_WAN]},
      "search_lan"      : true,
      "use_sync_trash"  : false,
      "overwrite_changes" : false,
      "selective_sync"  : false
    }
  ]
}
RSLCFG
  sudo systemctl daemon-reload 2>$LOG_FILE 1>&2
  sudo systemctl --now ${disable_enable[$RSLSYNC_SLOAD]} rslsync@${PIGEOS_USER} 2>$LOG_FILE 1>&2
}

config_ssh() {
  sudo /usr/bin/raspi-config nonint do_ssh 0 2>$LOG_FILE 1>&2
  # SSH private key is req. for RSYNC/UNISON
  if [ ! -f $PIGEOS_HOME/.ssh/id_rsa ]; then
    ssh-keygen -t rsa -f ~/.ssh/id_rsa -q -P ''
  fi
}

config_boot() {
  # don't wait for the network
  sudo /usr/bin/raspi-config nonint do_boot_wait 1
  # set the default framebuff resolution to 1024x768 as this gives
  # a 4:3 image ration as it was commen in the old days...
  if [ "x$SCREEN_RESOLUTION" == "x" ]; then
  	screen_width=1024
	screen_height=768
  else
  	screen_width=${SCREEN_RESOLUTION%x*}
	screen_height=${SCREEN_RESOLUTION#*x}
  fi
  # furthermore most modern displays can handle this using HW scaling
  for option in "disable_overscan=1" "dtparam=i2c_arm=on" \
                "framebuffer_width=${screen_width}" \
				"framebuffer_height=${screen_height}" \
                "dtparam=audio=on" "disable_splash=1" "boot_delay=0"\
				"gpu_mem=64" "enable_uart=1" "hdmi_enable_4kp60=1"
  do
    grep -q "${option%=*}" $BOOT_CONFIG
	if [ $? -eq 0 ]; then
	  # option present -> alter the key=value pair
	  sudo sed -i "s/.*${option%=*}.*/${option}/" $BOOT_CONFIG
	else
	  echo append this missing option
	  sudo tee -a $BOOT_CONFIG <<<"${option}"
	fi
  done
  # disable 3d overlay drivers 
  sudo sed $BOOT_CONFIG -i -e "s/^dtoverlay=vc4-kms-v3d/#dtoverlay=vc4-kms-v3d/g"
  sudo sed $BOOT_CONFIG -i -e "s/^dtoverlay=vc4-fkms-v3d/#dtoverlay=vc4-fkms-v3d/g"
  # route all audio to one sink (req. for Pi4)
  for option in  'quiet' 'splash' 'logo.nologo'\
                 'snd_bcm2835.enable_hdmi=1'\
		         'snd_bcm2835.enable_headphones=1'\
                 'snd_bcm2835.enable_compat_alsa=1'
  do
    grep -q "${option%=*}" $BOOT_CMDLINE 
	if [ $? -ne 0 ]; then
	 sudo sed -i "s/$/ $option/" $BOOT_CMDLINE
	  # TODO: update an existing key=value pair
	fi
  done
}

setup() {
  # 1st stage: install executes all modules in the default order
  install_dep_pkg $PKG_LIST 	|| return 1
  install_dosbox_pkg      	  	|| return 2
  install_pigeos_scripts  	  	|| return 3
  install_pigeos_config   	  	|| return 4
  install_pigeos_loader   	  	|| return 5
  install_splash_screen   	  	|| return 6
  install_dosbox_modem    	  	|| return 7
  install_dosbox_telnetd  	  	|| return 8
  install_usbmount     	  	  	|| return 9
  install_rslsync				|| return 10
  install_cups	  	  	  	  	|| return 11
  install_midi					|| return 12
  # enable 2nd stage setup execution in system default config
  sudo sed -i 's/CONTINUE_SETUP=.*/CONTINUE_SETUP=2/' \
  	$PIGEOS_PREFIX/etc/$(basename "$URL_CONFIG_SYSCFG")
}

install_stage2() {
  # 2nd stage: try to update the entire system before proceed
  sudo apt update --fix-missing; sudo apt -y upgrade
  # enable 3rd stage setup execution in system default config
  sudo sed -i 's/CONTINUE_SETUP=.*/CONTINUE_SETUP=3/' \
  	$PIGEOS_PREFIX/etc/$(basename "$URL_CONFIG_SYSCFG")
}

install_stage3() {
  # 3rd stage: install configures core services using system default config
  . $PIGEOS_PREFIX/etc/$(basename "$URL_CONFIG_SYSCFG")
  config_splash_screen
  config_dosbox_pkg
  config_dosbox_modem
  config_dosbox_telnetd
  config_usbmount
  config_midi
  config_boot
  # clear 2nd stage setup execution in system default config
  sudo sed -i 's/CONTINUE_SETUP=.*/CONTINUE_SETUP=0/' \
  	$PIGEOS_PREFIX/etc/$(basename "$URL_CONFIG_SYSCFG")
}

update() {
  # upd. apt sources first and try to fix missing packges
  sudo apt update --fix-missing
  # install latest Pi/GEOS files from Git master repo
  install_dosbox_pkg      	  	|| return 2
  install_pigeos_scripts  	  	|| return 3
  install_pigeos_config   	  	|| return 4
}

configure() { 
  # (re)configure services using user config
  . $PIGEOS_HOME/.pigeos
  # echo percentage value to visualize progress in pigeos-config
  config_dosbox_pkg				&& echo 20
  config_midi 					&& echo 40
  config_cups 					&& echo 60
  config_rslsync 				&& echo 80
  config_boot					&& echo 100
  exit 0
}

### Main ###
>$LOG_FILE
if [ $# -ne 0 ]; then
  # exec the given module
  $@
else
  usage
fi
echo "Finished! Wait 10s to reboot or press Ctrl+C to return to the shell."; sleep 10
sudo reboot
